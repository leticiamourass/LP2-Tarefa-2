1. Diferença entre Polimorfismo em Tempo de Execução e Polimorfismo em Tempo de Compilação
O polimorfismo é um conceito central na programação orientada a objetos, onde objetos de diferentes classes podem ser tratados de maneira uniforme, permitindo que métodos ou comportamentos sejam definidos de forma geral.

Polimorfismo em Tempo de Compilação (Estático):
Definição: O polimorfismo em tempo de compilação ocorre quando a decisão de qual método será chamado é tomada pelo compilador, ou seja, no momento da compilação.
Como funciona: Isso geralmente acontece com a sobrecarga de métodos ou sobrecarga de operadores, onde o compilador escolhe qual versão de um método será chamada com base no número e tipo de parâmetros passados.

Exemplo:
class MathOperation {
    // Sobrecarga de métodos
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        MathOperation operation = new MathOperation();
        System.out.println(operation.add(5, 3));        // Chama add(int, int)
        System.out.println(operation.add(5.5, 3.2));    // Chama add(double, double)
    }
}

Por que é chamado de "estático": O tipo de método a ser invocado é resolvido em tempo de compilação, antes da execução do código.
Polimorfismo em Tempo de Execução (Dinâmico):

Definição: O polimorfismo em tempo de execução ocorre quando a decisão de qual método será chamado é tomada durante a execução do programa, com base no tipo real do objeto.
Como funciona: Isso geralmente ocorre com sobrescrita de métodos (ou override) em classes derivadas. O método a ser chamado é determinado em tempo de execução, usando o tipo real do objeto, mesmo que o tipo referenciado seja o tipo da superclasse.
Exemplo:
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal myDog = new Dog(); // Tipo da variável é Animal, mas o objeto é Dog
        Animal myCat = new Cat(); // Tipo da variável é Animal, mas o objeto é Cat

        myDog.sound();  // Chama Dog's sound() method
        myCat.sound();  // Chama Cat's sound() method
    }
}

Por que é chamado de "dinâmico": O tipo real do objeto é resolvido em tempo de execução, quando o método é invocado, permitindo a execução de métodos específicos de subclasses.

2. Diferença entre Herança, Composição e Agregação
Herança: É uma relação entre classes onde uma classe herda os atributos e métodos de outra classe. A herança é usada quando uma classe "é um" tipo da outra.
Exemplo: Um Cachorro "é um" Animal. O Cachorro herda as propriedades e métodos de Animal.

class Animal {
    public void eat() {
        System.out.println("Eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Barking");
    }
}

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Herdado de Animal
        dog.bark(); // Método da classe Dog
    }
}

Composição: A composição é uma forma forte de associação onde uma classe é composta de outra, formando uma relação "tem um". A classe composta não pode existir sem a classe que ela contém.
Exemplo: Um Carro "tem um" Motor. O motor não pode existir sem o carro.
class Motor {
    public void start() {
        System.out.println("Motor started");
    }
}

class Carro {
    private Motor motor;  // Composição: Carro tem um Motor

    public Carro() {
        motor = new Motor();  // O carro cria o motor
    }

    public void startCar() {
        motor.start();
        System.out.println("Car started");
    }
}

public class Test {
    public static void main(String[] args) {
        Carro carro = new Carro();
        carro.startCar();
    }
}

Agregação: A agregação é uma forma mais fraca de associação em que uma classe pode conter outra, mas as classes podem existir independentemente. Ou seja, uma classe "tem um" objeto de outra classe, mas o objeto pode existir fora da classe que o contém.
Exemplo: Uma Biblioteca "tem um" Livro. O livro pode existir independentemente de estar ou não na biblioteca.
class Livro {
    private String title;

    public Livro(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}

class Biblioteca {
    private List<Livro> livros;  // Agregação: Biblioteca tem livros

    public Biblioteca() {
        livros = new ArrayList<>();
    }

    public void addLivro(Livro livro) {
        livros.add(livro);
    }

    public void showBooks() {
        for (Livro livro : livros) {
            System.out.println(livro.getTitle());
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Livro livro1 = new Livro("Java Programming");
        Livro livro2 = new Livro("Data Structures");
        
        Biblioteca biblioteca = new Biblioteca();
        biblioteca.addLivro(livro1);
        biblioteca.addLivro(livro2);
        
        biblioteca.showBooks();
    }
}

Resumo das Diferenças:
Herança: A classe filha "é um" tipo da classe pai. A classe filha herda os membros da classe pai.
Composição: A classe "tem um" objeto de outra classe. A classe composta depende da classe contida para sua existência.
Agregação: A classe "tem um" objeto, mas o objeto pode existir de forma independente da classe agregadora.
